{"version":3,"sources":["modules/Mobius/MobiusStyles.js","modules/MobiusInteractive/MobiusInteractive.js","modules/Mobius/Mobius.js","App.js","serviceWorker.js","index.js"],"names":["OuterContainer","styled","div","_templateObject","FlexContainer","_templateObject2","StyledInput","input","_templateObject3","StyledSpan","span","_templateObject4","Button","button","_templateObject5","Canvas","canvas","_templateObject6","MobiusInteractive","Component","state","minX","maxX","minY","maxY","screenWidth","screenHeight","a","math","complex","b","c","d","a_str","re","im","b_str","c_str","d_str","points","findBorderValuesOnMobiusLine","x0","y0","x1","y1","fp","_this","calculatePoint","pomakX","pomakY","i","z","res","findBorderValues","borderValues","borderValues2","calculateMobiusBorders","borderCordinates","length","p1","p2","Math","abs","drawMobius","ctx","mobiusBorderValues","drawLine3","drawUntransformed","_this$state","drawLine2","drawPointName","p","text","x","y","font","fillStyle","fillText","onClickHandler","redraw","onMoveHandler","e","rect","document","getElementById","getBoundingClientRect","clientX","left","clientY","top","point","calculatePositionFromRaster","concat","setState","onChangeHandler","el","isRealPart","value","target","val","parseFloat","elStr","numStr","num","isNaN","console","log","boudingCordinates","_this$state2","pY","pX","addPoint","_this$state3","_this$state4","this","divide","sum","multiply","_this$state5","_this$state6","calculateRasterPosition2","centerX","centerY","distX","distY","xx","toFixed","yy","fillRect","getContext","clearRect","width","height","c2","ctx2","drawCordinateAxis","drawCordinateAxis2","_this2","react_default","createElement","type","onChange","onClick","id","onMouseMove","onMouseOut","pop","onMouseEnter","App","className","modules_MobiusInteractive_MobiusInteractive","Boolean","window","location","hostname","match","ReactDOM","render","src_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e4f1488f.chunk.js","sourcesContent":["import styled from 'styled-components'\n\nexport const OuterContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n`;\n\nexport const FlexContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n`;\n\nexport const StyledInput = styled.input`\n  width: 40px;\n  border-radius: 4px;\n  border: 1px solid lightgray;\n`;\n\nexport const StyledSpan = styled.span`\n  width: 50px;\n  text-align: center;\n  display: inline-block;\n`;\n\nexport const Button = styled.button`\n  color: white;\n  background-color: #2c71e0;\n  padding: 10px 20px;\n  border-radius: 4px;\n  border: 1px solid #0E5DD9; \n`;\n\nexport const Canvas = styled.canvas`\n  border: 1px solid lightgrey;\n  margin: 20px;\n`;","import React, { Component } from 'react';\n\nimport math from 'mathjs';\nimport {\n  OuterContainer,\n  FlexContainer,\n  StyledInput,\n  StyledSpan,\n  Button,\n  Canvas,\n} from '../Mobius/MobiusStyles.js';\n\nclass MobiusInteractive extends Component {\n  state = {\n    minX: -5,\n    maxX: 5,\n    minY: -5,\n    maxY: 5,\n    screenWidth: 500,\n    screenHeight: 500,\n    a: math.complex(1, 5),\n    b: math.complex(2, 5),\n    c: math.complex(2, 5),\n    d: math.complex(1, 5),\n    a_str: {\n      re: '1',\n      im: '5',\n    },\n    b_str: {\n      re: '2',\n      im: '5',\n    },\n    c_str: {\n      re: '2',\n      im: '5',\n    },\n    d_str: {\n      re: '1',\n      im: '5',\n    },\n    points: [] \n  };\n\n  calculatePoint(z) {\n    const { a, b, c, d } = this.state;\n    const res = math.divide(\n      math.sum(math.multiply(a, z), b),\n      math.sum(math.multiply(c, z), d)\n    );\n    return res;\n  }\n\n  \n  calculateRasterPosition2(x, y, borderCordinates) {\n    const { screenWidth, screenHeight } = this.state;\n    const { minX, maxX, minY, maxY } = borderCordinates; \n    const distX = maxX - minX;\n    const distY = maxY - minY;\n    const rx = ((x - minX) / distX) * screenWidth;\n    const ry = screenHeight - ((y - minY) / distY) * screenHeight;\n    return { x: rx, y: ry };\n  }\n\n  drawCordinateAxis(ctx) {\n    const { minX, maxX, minY, maxY } = this.state;\n    const borderCordinates = { minX, maxX, minY, maxY };\n    this.drawLine2(ctx, 0, minY, 0, maxY, borderCordinates);\n    this.drawLine2(ctx, minX, 0, maxX, 0, borderCordinates);\n    ctx.font = '10px Arial';\n    for (let i = minX + 1; i < maxX; i++) {\n      const point = this.calculateRasterPosition2(i, 0, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(i, x, y - 10);\n    }\n    for (let i = minY + 1; i < maxY; i++) {\n      const point = this.calculateRasterPosition2(0, i, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(i, x + 10, y);\n    }\n  }\n\n  drawCordinateAxis2(ctx, borderCordinates) {\n    const { minX, maxX, minY, maxY } = borderCordinates;\n    const centerX = (maxX + minX) / 2;\n    const centerY = (maxY + minY) / 2;\n    this.drawLine2(ctx, centerX, minY, centerX, maxY, borderCordinates);\n    this.drawLine2(ctx, minX, centerY, maxX, centerY, borderCordinates);\n    const distX = (maxX - minX) / 10;\n    const distY = (maxY - minY) / 10;\n    ctx.font = '10px Arial';\n    for (let i = 1; i < 10; i++) {\n      const xx = minX + i * distX;\n      const point = this.calculateRasterPosition2(xx, centerY, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(xx.toFixed(2), x, y - 10 );\n    }\n    for (let i = 1; i < 10; i++) {\n      const yy = minY + i * distY;\n      const point = this.calculateRasterPosition2(centerX, yy, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(yy.toFixed(2), x, y);\n    }\n    \n  }\n\n  drawLine2(ctx, x0, y0, x1, y1, borderCordinates) {\n    const pomakX = (x1 - x0) / 10000.0;\n    const pomakY = (y1 - y0) / 10000.0;\n    for (let i = 0; i <= 10000; i++) {\n      const z = math.complex(x0 + i * pomakX, y0 + i * pomakY);\n      const point = this.calculateRasterPosition2(z.re, z.im, borderCordinates);\n      const { x, y } = point;\n      ctx.fillRect(x, y, 1, 1);\n    }\n  }\n\n  drawLine3(ctx, x0, y0, x1, y1, borderCordinates) {\n    const pomakX = (x1 - x0) / 10000.0;\n    const pomakY = (y1 - y0) / 10000.0;\n    for (let i = 0; i <= 10000; i++) {\n      const z = math.complex(x0 + i * pomakX, y0 + i * pomakY);\n      const res = this.calculatePoint(z);\n      const point = this.calculateRasterPosition2(res.re, res.im, borderCordinates);\n      const { x, y } = point;\n      ctx.fillRect(x, y, 1, 1);\n    }\n  }\n\n  findBorderValuesOnMobiusLine = (x0, y0, x1, y1) => {\n    const fp = this.calculatePoint(math.complex(x0,y0));\n    let minX = fp.re;\n    let maxX = fp.re;\n    let minY = fp.im;\n    let maxY = fp.im;\n    const pomakX = (x1 - x0) / 10000.0;\n    const pomakY = (y1 - y0) / 10000.0;\n    for (let i = 0; i <= 10000; i++) {\n      const z = math.complex(x0 + i * pomakX, y0 + i * pomakY);\n      const res = this.calculatePoint(z);\n      if (res.re > maxX) {\n        maxX = res.re;\n      }\n      if (res.re < minX) {\n        minX = res.re;\n      }\n      if (res.im > maxY) {\n        maxY = res.im;\n      }\n      if (res.im < minY) {\n        minY = res.im;\n      }\n    }\n    return { minX, maxX, minY, maxY };\n  }\n\n  findBorderValues = (borderValues, borderValues2) => {\n    let { minX, maxX, minY,maxY } = borderValues;\n    if (borderValues2.maxX > maxX) {\n      maxX = borderValues2.maxX;\n    }\n    if (borderValues2.minX < minX) {\n      minX = borderValues2.minX;\n    }\n    if (borderValues2.maxY > maxY) {\n      maxY = borderValues2.maxY;\n    }\n    if (borderValues2.minY < minY) {\n      minY = borderValues2.minY;\n    }\n    return {minX, maxX, minY, maxY}\n  }\n\n  calculateMobiusBorders = () => {\n    const { points } = this.state;\n    let borderCordinates = null;\n    if (points.length >= 2) {\n      let p1 = points[0];\n      let p2 = points[1];\n      borderCordinates = this.findBorderValuesOnMobiusLine(p1.re, p1.im, p2.re, p2.im);\n    }\n    else {\n      return borderCordinates;\n    }\n    for (let i = 1; i < points.length - 1; i++) {\n      let p1 = points[i];\n      let p2 = points[i + 1];\n      borderCordinates = this.findBorderValues(borderCordinates, this.findBorderValuesOnMobiusLine(p1.re, p1.im, p2.re, p2.im));\n    }\n    let p1 = points[points.length - 1];\n    let p2 = points[0];\n    borderCordinates = this.findBorderValues(borderCordinates, this.findBorderValuesOnMobiusLine(p1.re, p1.im, p2.re, p2.im));\n    borderCordinates.minX -= 0.2 * Math.abs(borderCordinates.minX); \n    borderCordinates.maxX += 0.2 * Math.abs(borderCordinates.maxX); \n    borderCordinates.minY -= 0.2 * Math.abs(borderCordinates.minY); \n    borderCordinates.maxY += 0.2 * Math.abs(borderCordinates.maxY); \n    return borderCordinates;\n  }\n\n  drawMobius = (ctx, mobiusBorderValues) => {\n    const { points } = this.state;\n    for (let i = 0; i < points.length - 1; i++) {\n      const p1 = points[i];\n      const p2 = points[i + 1]\n      this.drawLine3(ctx, p1.re, p1.im, p2.re, p2.im, mobiusBorderValues);\n    }\n    if (points.length > 0) {\n      const p1 = points[points.length - 1];\n      const p2 = points[0]\n      this.drawLine3(ctx, p1.re, p1.im, p2.re, p2.im, mobiusBorderValues);\n    }\n    \n  };\n\n  drawUntransformed = (ctx) => {\n    const {points, minX, maxX, minY, maxY} = this.state;\n    const borderCordinates = { minX, maxX, minY, maxY }\n    for (let i = 0; i < points.length - 1; i++) {\n      const p1 = points[i];\n      const p2 = points[i + 1];\n      this.drawLine2(ctx, p1.re, p1.im, p2.re, p2.im, borderCordinates);\n    }\n    if (points.length > 0) {\n      const p1 = points[points.length - 1];\n      const p2 = points[0];\n      this.drawLine2(ctx, p1.re, p1.im, p2.re, p2.im, borderCordinates);\n    }\n  }\n\n  drawPointName = (ctx, p, text) => {\n    const {x, y} = p;\n    const font = ctx.font;\n    const fillStyle = ctx.fillStyle;\n    ctx.font = '20px Arial';\n    ctx.fillStyle = 'red';\n    ctx.fillText(text, x, y);\n    ctx.font = font;\n    ctx.fillStyle = fillStyle;\n  }\n\n  async redraw() {\n    const c = document.getElementById('canvas_basic_sketch');\n    const ctx = c.getContext('2d');\n    ctx.clearRect(0, 0, c.width, c.height);\n    const c2 = document.getElementById('my_canvas');\n    const ctx2 = c2.getContext('2d');\n    ctx2.clearRect(0, 0, c2.width, c2.height);\n\n    const mobiusBorderValues = this.calculateMobiusBorders();\n    \n    this.drawCordinateAxis(ctx);\n    this.drawUntransformed(ctx);\n    if (mobiusBorderValues) {\n      this.drawCordinateAxis2(ctx2, mobiusBorderValues);\n      this.drawMobius(ctx2, mobiusBorderValues);\n    }\n\n    \n\n    const { minX, maxX, minY, maxY, points } = this.state;\n    const borderCordinates = { minX, maxX, minY, maxY };\n    for (let i = 0; i < points.length; i++) {\n      this.drawPointName(ctx, this.calculateRasterPosition2(points[i].re, points[i].im, borderCordinates), `p${i+1}`);\n      if (mobiusBorderValues) {\n        const x = this.calculatePoint(points[i])\n        this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), `p${i+1}`)\n      }\n    }\n    // this.drawPointName(ctx, this.calculateRasterPosition2(p1.re, p1.im, borderCordinates), 'p1');\n    // this.drawPointName(ctx, this.calculateRasterPosition2(p2.re, p2.im, borderCordinates), 'p2');\n    // this.drawPointName(ctx, this.calculateRasterPosition2(p3.re, p3.im, borderCordinates), 'p3');\n    // this.drawPointName(ctx, this.calculateRasterPosition2(p4.re, p4.im, borderCordinates), 'p4');\n    \n    // let x = this.calculatePoint(p1)\n    // this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p1');\n    // x = this.calculatePoint(p2);\n    // this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p2');\n    // x = this.calculatePoint(p3);\n    // this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p3');\n    // x = this.calculatePoint(p4);\n    // this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p4');\n    \n  }\n\n  onClickHandler = () => {\n    this.redraw()\n  }\n\n  onMoveHandler = (e) => {\n    let { points } = this.state;\n    \n    const canvas = document.getElementById('canvas_basic_sketch');\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = this.state.screenHeight - (e.clientY - rect.top);\n    \n    const boundingCodinates = { minX: - 5, maxX: 5, minY: -5, maxY: 5 }\n    const point = this.calculatePositionFromRaster(x, y,boundingCodinates);\n    if (points.length === 0) {\n      points = points.concat(point)\n    }\n    else {\n      points[points.length - 1] = point;\n    }\n    this.setState({\n      points\n    }, () =>{\n      this.redraw()\n    });\n    \n    // if (points.length > 0) {\n    //   points[points.length - 1] =\n    // }\n  }\n\n  // onChangeHandler= (el, isRealPart, e) => {\n  //   let value = parseFloat(e.target.value);\n  //   if (isNaN(value)) {\n  //     value = 0\n  //   }\n  //   const num = this.state[el];\n  //   if (isRealPart) {\n  //     num.re = value;\n  //   }\n  //   else {\n  //     num.im = value;\n  //   }\n  //   this.setState({\n  //     el: num\n  //   })\n  //   console.log(this.state);\n  //   this.redraw();\n  // }\n\n  onChangeHandler = (el, isRealPart, e) => {\n\n    let value = e.target.value;\n    const val = parseFloat(value)\n    const elStr = `${el}_str`\n\n    const numStr = this.state[elStr];\n    const num = this.state[el];\n    if (isRealPart) {\n      numStr.re = value;\n      if (!isNaN(val)) {\n        num.re = val;\n      }\n    }\n    else {\n      numStr.im = value;\n      if (!isNaN(val)) {\n        num.im = val;\n      }\n    }\n    this.setState({\n      el: num,\n      elStr: numStr\n    })\n    console.log(this.state);\n    this.redraw();\n  }\n\n  calculatePositionFromRaster = (x, y, boudingCordinates) => {\n    const { minX, maxX, minY, maxY } = boudingCordinates;\n    const { screenHeight, screenWidth } = this.state;\n    const distX = maxX - minX;\n    const distY = maxY - minY;\n    const pY = minY + distY * (y / screenHeight);\n    const pX = minX + distX * (x / screenWidth);\n    const point = math.complex(pX, pY);\n    return point\n  }\n\n  addPoint = (e) => {\n    // console.log(e)\n    const canvas = document.getElementById('canvas_basic_sketch');\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = this.state.screenHeight - (e.clientY - rect.top);\n    console.log('x: ', x, 'y: ', y);\n    let {minX, maxX, minY, maxY, points }= this.state;\n    const boundingCodinates = { minX: - 5, maxX: 5, minY: -5, maxY: 5 }\n    const point = this.calculatePositionFromRaster(x, y,boundingCodinates);\n    points = points.concat(point)\n    this.setState({\n      points\n    }, () =>{\n      this.redraw()\n    });\n    \n  } \n  componentDidMount() {\n    const c = document.getElementById('my_canvas');\n    const ctx = c.getContext('2d');\n    this.drawCordinateAxis(ctx);\n    const c2 = document.getElementById('canvas_basic_sketch');\n    const ctx2 = c2.getContext('2d');\n    this.drawCordinateAxis(ctx2);\n  }\n  render() {\n    return (\n      <OuterContainer>\n        <div>\n          <FlexContainer>\n            <div>\n              <StyledSpan>a =</StyledSpan> \n              <StyledInput \n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('a', true, e)}}\n                value={this.state.a_str.re}\n              /> + \n              <StyledInput type=\"text\"\n                onChange={(e) => {this.onChangeHandler('a', false, e)}}\n                value={this.state.a_str.im}\n              /> i\n            </div>\n            <div>\n              <StyledSpan>b =</StyledSpan>\n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('b', true, e)}}\n                value={this.state.b_str.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('b', false, e)}}\n                value={this.state.b_str.im}  \n              /> i\n            </div>\n            <div>\n              <StyledSpan>c =</StyledSpan>\n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('c', true, e)}}\n                value={this.state.c_str.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('c', false, e)}}\n                value={this.state.c_str.im}\n              /> i\n            </div>\n            <div>\n              <StyledSpan>d =</StyledSpan>\n              <StyledInput \n                type=\"text\" \n                onChange={(e) => {this.onChangeHandler('d', true, e)}}\n                value={this.state.d_str.re}\n              /> + \n              <StyledInput\n                type=\"text\" \n                onChange={(e) => {this.onChangeHandler('d', false, e)}}\n                value={this.state.d_str.im}\n              /> i\n            </div>\n          </FlexContainer>\n          <Button onClick={this.onClickHandler}>Nacrtaj</Button>\n        </div>\n        <div>\n          <Canvas id=\"canvas_basic_sketch\" width=\"500px\" height=\"500px\" \n            onClick={this.addPoint} \n            onMouseMove={this.onMoveHandler}\n            onMouseOut={() => {\n              const { points } = this.state;\n              points.pop();\n              this.setState({\n                points\n              },() => {\n                this.redraw()\n              })\n            }}\n            onMouseEnter={this.addPoint}\n          />\n          <Canvas id=\"my_canvas\" width=\"500px\" height=\"500px\" />\n        </div>\n      </OuterContainer>\n    );\n  }\n}\n\nexport default MobiusInteractive;\n","import React, { Component } from 'react';\n\nimport math from 'mathjs';\nimport {\n  OuterContainer,\n  FlexContainer,\n  StyledInput,\n  StyledSpan,\n  Button,\n  Canvas,\n} from './MobiusStyles';\n\nclass Mobius extends Component {\n  state = {\n    minX: -5,\n    maxX: 5,\n    minY: -5,\n    maxY: 5,\n    screenWidth: 500,\n    screenHeight: 500,\n    a: math.complex(1, 5),\n    b: math.complex(2, 5),\n    c: math.complex(2, 5),\n    d: math.complex(1, 5),\n    p1: math.complex(0, 0),\n    p2: math.complex(-2, 0),\n    p3: math.complex(-2, 2),\n    p4: math.complex(0, 2) \n  };\n\n  calculatePoint(z) {\n    const { a, b, c, d } = this.state;\n    const res = math.divide(\n      math.sum(math.multiply(a, z), b),\n      math.sum(math.multiply(c, z), d)\n    );\n    return res;\n  }\n\n  \n  calculateRasterPosition2(x, y, borderCordinates) {\n    const { screenWidth, screenHeight } = this.state;\n    const { minX, maxX, minY, maxY } = borderCordinates; \n    const distX = maxX - minX;\n    const distY = maxY - minY;\n    const rx = ((x - minX) / distX) * screenWidth;\n    const ry = screenHeight - ((y - minY) / distY) * screenHeight;\n    return { x: rx, y: ry };\n  }\n\n  drawCordinateAxis(ctx) {\n    const { minX, maxX, minY, maxY } = this.state;\n    const borderCordinates = { minX, maxX, minY, maxY };\n    this.drawLine2(ctx, 0, minY, 0, maxY, borderCordinates);\n    this.drawLine2(ctx, minX, 0, maxX, 0, borderCordinates);\n    ctx.font = '10px Arial';\n    for (let i = minX + 1; i < maxX; i++) {\n      const point = this.calculateRasterPosition2(i, 0, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(i, x, y - 10);\n    }\n    for (let i = minY + 1; i < maxY; i++) {\n      const point = this.calculateRasterPosition2(0, i, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(i, x + 10, y);\n    }\n  }\n\n  drawCordinateAxis2(ctx, borderCordinates) {\n    const { minX, maxX, minY, maxY } = borderCordinates;\n    const centerX = (maxX + minX) / 2;\n    const centerY = (maxY + minY) / 2;\n    this.drawLine2(ctx, centerX, minY, centerX, maxY, borderCordinates);\n    this.drawLine2(ctx, minX, centerY, maxX, centerY, borderCordinates);\n    const distX = (maxX - minX) / 10;\n    const distY = (maxY - minY) / 10;\n    ctx.font = '10px Arial';\n    for (let i = 1; i < 10; i++) {\n      const xx = minX + i * distX;\n      const point = this.calculateRasterPosition2(xx, centerY, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(xx.toFixed(2), x, y - 10 );\n    }\n    for (let i = 1; i < 10; i++) {\n      const yy = minY + i * distY;\n      const point = this.calculateRasterPosition2(centerX, yy, borderCordinates);\n      const { x, y } = point;\n      ctx.fillText(yy.toFixed(2), x, y);\n    }\n    \n  }\n\n  drawLine2(ctx, x0, y0, x1, y1, borderCordinates) {\n    const pomakX = (x1 - x0) / 10000.0;\n    const pomakY = (y1 - y0) / 10000.0;\n    for (let i = 0; i <= 10000; i++) {\n      const z = math.complex(x0 + i * pomakX, y0 + i * pomakY);\n      const point = this.calculateRasterPosition2(z.re, z.im, borderCordinates);\n      const { x, y } = point;\n      ctx.fillRect(x, y, 1, 1);\n    }\n  }\n\n  drawLine3(ctx, x0, y0, x1, y1, borderCordinates) {\n    const pomakX = (x1 - x0) / 10000.0;\n    const pomakY = (y1 - y0) / 10000.0;\n    for (let i = 0; i <= 10000; i++) {\n      const z = math.complex(x0 + i * pomakX, y0 + i * pomakY);\n      const res = this.calculatePoint(z);\n      const point = this.calculateRasterPosition2(res.re, res.im, borderCordinates);\n      const { x, y } = point;\n      ctx.fillRect(x, y, 1, 1);\n    }\n  }\n\n  findBorderValuesOnMobiusLine = (x0, y0, x1, y1) => {\n    const fp = this.calculatePoint(math.complex(x0,y0));\n    let minX = fp.re;\n    let maxX = fp.re;\n    let minY = fp.im;\n    let maxY = fp.im;\n    const pomakX = (x1 - x0) / 10000.0;\n    const pomakY = (y1 - y0) / 10000.0;\n    for (let i = 0; i <= 10000; i++) {\n      const z = math.complex(x0 + i * pomakX, y0 + i * pomakY);\n      const res = this.calculatePoint(z);\n      if (res.re > maxX) {\n        maxX = res.re;\n      }\n      if (res.re < minX) {\n        minX = res.re;\n      }\n      if (res.im > maxY) {\n        maxY = res.im;\n      }\n      if (res.im < minY) {\n        minY = res.im;\n      }\n    }\n    return { minX, maxX, minY, maxY };\n  }\n\n  findBorderValues = (borderValues, borderValues2) => {\n    let { minX, maxX, minY,maxY } = borderValues;\n    if (borderValues2.maxX > maxX) {\n      maxX = borderValues2.maxX;\n    }\n    if (borderValues2.minX < minX) {\n      minX = borderValues2.minX;\n    }\n    if (borderValues2.maxY > maxY) {\n      maxY = borderValues2.maxY;\n    }\n    if (borderValues2.minY < minY) {\n      minY = borderValues2.minY;\n    }\n    return {minX, maxX, minY, maxY}\n  }\n\n  calculateMobiusBorders = () => {\n    const {p1, p2, p3, p4 } = this.state;\n    let borderCordinates = this.findBorderValuesOnMobiusLine(p1.re, p1.im, p2.re, p2.im);\n    borderCordinates = this.findBorderValues(borderCordinates, this.findBorderValuesOnMobiusLine(p2.re, p2.im, p3.re, p3.im));\n    borderCordinates = this.findBorderValues(borderCordinates, this.findBorderValuesOnMobiusLine(p3.re, p3.im, p4.re, p4.im));\n    borderCordinates = this.findBorderValues(borderCordinates, this.findBorderValuesOnMobiusLine(p4.re, p4.im, p1.re, p1.im));\n    borderCordinates.minX -= 0.2 * Math.abs(borderCordinates.minX); \n    borderCordinates.maxX += 0.2 * Math.abs(borderCordinates.maxX); \n    borderCordinates.minY -= 0.2 * Math.abs(borderCordinates.minY); \n    borderCordinates.maxY += 0.2 * Math.abs(borderCordinates.maxY); \n    return borderCordinates;\n  }\n\n  drawMobius = (ctx, mobiusBorderValues) => {\n    const { p1, p2, p3, p4 } = this.state;\n    this.drawLine3(ctx, p1.re, p1.im, p2.re, p2.im, mobiusBorderValues);\n    this.drawLine3(ctx, p2.re, p2.im, p3.re, p3.im, mobiusBorderValues);\n    this.drawLine3(ctx, p3.re, p3.im, p4.re, p4.im, mobiusBorderValues);\n    this.drawLine3(ctx, p4.re, p4.im, p1.re, p1.im, mobiusBorderValues);\n  };\n\n  drawUntransformed = (ctx) => {\n    const {p1, p2, p3, p4, minX, maxX, minY, maxY} = this.state;\n    const borderCordinates = { minX, maxX, minY, maxY }\n    this.drawLine2(ctx, p1.re, p1.im, p2.re, p2.im, borderCordinates);\n    this.drawLine2(ctx, p2.re, p2.im, p3.re, p3.im, borderCordinates);\n    this.drawLine2(ctx, p3.re, p3.im, p4.re, p4.im, borderCordinates);\n    this.drawLine2(ctx, p4.re, p4.im, p1.re, p1.im, borderCordinates);\n  }\n\n  drawPointName = (ctx, p, text) => {\n    const {x, y} = p;\n    const font = ctx.font;\n    const fillStyle = ctx.fillStyle;\n    ctx.font = '20px Arial';\n    ctx.fillStyle = 'red';\n    ctx.fillText(text, x, y);\n    ctx.font = font;\n    ctx.fillStyle = fillStyle;\n  }\n\n  async redraw() {\n    const c = document.getElementById('canvas_basic_sketch');\n    const ctx = c.getContext('2d');\n    ctx.clearRect(0, 0, c.width, c.height);\n    const c2 = document.getElementById('my_canvas');\n    const ctx2 = c2.getContext('2d');\n    ctx2.clearRect(0, 0, c2.width, c2.height);\n\n    const mobiusBorderValues = this.calculateMobiusBorders();\n    \n    this.drawCordinateAxis(ctx);\n    this.drawCordinateAxis2(ctx2, mobiusBorderValues);\n    this.drawUntransformed(ctx);\n\n    this.drawMobius(ctx2, mobiusBorderValues);\n\n    const { p1, p2, p3, p4, minX, maxX, minY, maxY } = this.state;\n    const borderCordinates = { minX, maxX, minY, maxY };\n    this.drawPointName(ctx, this.calculateRasterPosition2(p1.re, p1.im, borderCordinates), 'p1');\n    this.drawPointName(ctx, this.calculateRasterPosition2(p2.re, p2.im, borderCordinates), 'p2');\n    this.drawPointName(ctx, this.calculateRasterPosition2(p3.re, p3.im, borderCordinates), 'p3');\n    this.drawPointName(ctx, this.calculateRasterPosition2(p4.re, p4.im, borderCordinates), 'p4');\n    \n    let x = this.calculatePoint(p1)\n    this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p1');\n    x = this.calculatePoint(p2);\n    this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p2');\n    x = this.calculatePoint(p3);\n    this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p3');\n    x = this.calculatePoint(p4);\n    this.drawPointName(ctx2, this.calculateRasterPosition2(x.re, x.im, mobiusBorderValues), 'p4');\n    \n  }\n\n  onClickHandler = () => {\n    this.redraw()\n  }\n\n  onChangeHandler= (el, isRealPart, e) => {\n    let value = parseFloat(e.target.value);\n    if (isNaN(value)) {\n      value = 0\n    }\n    const num = this.state[el];\n    if (isRealPart) {\n      num.re = value;\n    }\n    else {\n      num.im = value;\n    }\n    this.setState({\n      el: num\n    })\n    console.log(this.state);\n    this.redraw();\n  }\n\n  componentDidMount() {\n    const c = document.getElementById('my_canvas');\n    const ctx = c.getContext('2d');\n    this.drawCordinateAxis(ctx);\n    const c2 = document.getElementById('canvas_basic_sketch');\n    const ctx2 = c2.getContext('2d');\n    this.drawCordinateAxis(ctx2);\n  }\n  render() {\n    return (\n      <OuterContainer>\n        <div>\n          <FlexContainer>\n            <div>\n              <StyledSpan>a =</StyledSpan> \n              <StyledInput \n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('a', true, e)}}\n                value={this.state.a.re}\n              /> + \n              <StyledInput type=\"text\"\n                onChange={(e) => {this.onChangeHandler('a', false, e)}}\n                value={this.state.a.im}\n              /> i\n              <StyledSpan>p1 =</StyledSpan> \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('p1', true, e)}}\n                value={this.state.p1.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('p1', false, e)}}\n                value={this.state.p1.im}\n              /> i\n            </div>\n            <div>\n              <StyledSpan>b =</StyledSpan>\n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('b', true, e)}}\n                value={this.state.b.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('b', false, e)}}\n                value={this.state.b.im}  \n              /> i\n              <StyledSpan>p2 =</StyledSpan> \n              <StyledInput \n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('p2', true, e)}}\n                value={this.state.p2.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('p2', false, e)}}\n                value={this.state.p2.im}\n              /> i\n            </div>\n            <div>\n              <StyledSpan>c =</StyledSpan>\n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('c', true, e)}}\n                value={this.state.c.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('c', false, e)}}\n                value={this.state.c.im}\n              /> i\n              <StyledSpan>p3 =</StyledSpan> \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('p3', true, e)}}\n                value={this.state.p3.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('p3', false, e)}}\n                value={this.state.p3.im}\n              /> i\n            </div>\n            <div>\n              <StyledSpan>d =</StyledSpan>\n              <StyledInput \n                type=\"text\" \n                onChange={(e) => {this.onChangeHandler('d', true, e)}}\n                value={this.state.d.re}\n              /> + \n              <StyledInput\n                type=\"text\" \n                onChange={(e) => {this.onChangeHandler('d', false, e)}}\n                value={this.state.d.im}\n              /> i\n              <StyledSpan>p4 =</StyledSpan> \n              <StyledInput\n                type=\"text\" \n                onChange={(e) => {this.onChangeHandler('p4', true, e)}}\n                value={this.state.p4.re}\n              /> + \n              <StyledInput\n                type=\"text\"\n                onChange={(e) => {this.onChangeHandler('p4', false, e)}}\n                value={this.state.p4.im}\n              /> i\n            </div>\n          </FlexContainer>\n          <Button onClick={this.onClickHandler}>Nacrtaj</Button>\n        </div>\n        <div>\n          <Canvas id=\"canvas_basic_sketch\" width=\"500px\" height=\"500px\" />\n          <Canvas id=\"my_canvas\" width=\"500px\" height=\"500px\" />\n        </div>\n      </OuterContainer>\n    );\n  }\n}\n\nexport default Mobius;\n","import React, { Component } from 'react';\n\nimport Mobius from './modules/Mobius/Mobius';\nimport MobiusInteractive from './modules/MobiusInteractive/MobiusInteractive';\n\nclass App extends Component {\n  \n  render() {\n    return (\n      <div className=\"App\">\n        <MobiusInteractive/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport 'normalize.css';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}